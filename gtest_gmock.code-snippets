{
	//https://ctestcode.github.io/

	//https://google.github.io/googletest/reference/testing.html

	"TEST": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TEST",
		"body":[
			"TEST( ${1:TestSuiteName}, ${2:TestName})\n{\n$3\n}"
		],
		"description":"TEST(TestSuiteName, TestName) {\n  ... statements ...\n}\n\nDefines an individual test named TestName in the test suite TestSuiteName, \nconsisting of the given statements.\n\nBoth arguments TestSuiteName and TestName must \nbe valid C++ identifiers and must not contain underscores (_). \nTests in different test suites can have the same individual name.\n\nThe statements within the test body can be any code under \ntest. Assertions used within the test body determine the outcome \nof the test.  "
	},

	"TEST_F": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TEST_F",
		"body":[
			"TEST_F( ${1:TestSuiteName}, ${2:TestName})\n{\n$3\n}"
		],
		"description":"Prevents further test execution at runtime.\n\nCan be used in individual test cases or in the SetUp() \nmethods of test environments or test fixtures (classes derived \nfrom the Environment or Test classes). If used in a global test \nenvironment SetUp() method, it skips all tests in the test program. \nIf used in a test fixture SetUp() method, it skips all tests in \nthe corresponding test suite.\n\nSimilar to assertions, GTEST_SKIP allows streaming \na custom message into it.\n\nSee Skipping Test Execution for more information. "
	},
	"TEST_P": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TEST_P",
		"body":[
			"TEST_P( ${1:TestSuiteName}, ${2:TestName})\n{\n$3\n}"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nTEST_P(TestFixtureName, TestName) {\n  ... statements ...\n}\n----------------------------------------\n\nDefines an individual value-parameterized test named TestName \nthat uses the test fixture class TestFixtureName. The test suite \nname is TestFixtureName.\n\nBoth arguments TestFixtureName and TestName \nmust be valid C++ identifiers and must not contain underscores \n(_). TestFixtureName must be the name of a value-parameterized \ntest fixture class-see Value-Parameterized Tests.\n\nThe statements within the test body can be any code under \ntest. Within the test body, the test parameter can be accessed \nwith the GetParam() function (see WithParamInterface). For \nexample:\n\n++++++++++++++++++++++++++++++++++++++++\nTEST_P(MyTestSuite, DoesSomething) {\n  ...\n  EXPECT_TRUE(DoSomething(GetParam()));\n  ...\n}\n----------------------------------------\n\nAssertions used within the test body determine \nthe outcome of the test.\n\nSee also INSTANTIATE_TEST_SUITE_P. "
	},
	"INSTANTIATE_TEST_SUITE_P": {
		"scope": "c,cpp",
		"prefix": "g:Testing:INSTANTIATE_TEST_SUITE_P",
		"body":[
			"INSTANTIATE_TEST_SUITE_P(${1:InstantiationName},${2:TestSuiteName},${3:param_generator})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nINSTANTIATE_TEST_SUITE_P(InstantiationName,TestSuiteName,param_generator)\nINSTANTIATE_TEST_SUITE_P(InstantiationName,TestSuiteName,param_generator,name_generator)\n----------------------------------------\n\nInstantiates the value-parameterized test suite TestSuiteName \n(defined with TEST_P).\n\nThe argument InstantiationName is a unique name \nfor the instantiation of the test suite, to distinguish between \nmultiple instantiations. In test output, the instantiation \nname is added as a prefix to the test suite name TestSuiteName.\n\nThe argument param_generator is one of the \nfollowing GoogleTest-provided functions that generate the \ntest parameters, all defined in the ::testing namespace:\n\n++++++++++++++++++++++++++++++++++++++++\nParameter Generator                         Behavior\nRange(begin, end [, step])                  Yields values {begin, begin+step, begin+step+step, ...}. The values do not include end. step defaults to 1.\nValues(v1, v2, ..., vN)                     Yields values {v1, v2, ..., vN}.\nValuesIn(container) or ValuesIn(begin,end)  Yields values from a C-style array, an STL-style container, or an iterator range [begin, end).\nBool()                                      Yields sequence {false, true}.\nCombine(g1, g2, ..., gN)                    Yields as std::tuple n-tuples all combinations (Cartesian product) of the values generated by the given n generators g1, g2, ..., gN.\n----------------------------------------\n\nThe optional last argument name_generator is \na function or functor that generates custom test name suffixes \nbased on the test parameters. The function must accept an argument \nof type TestParamInfo<class ParamType> and return a std::string. \nThe test name suffix can only contain alphanumeric characters \nand underscores. GoogleTest provides PrintToStringParamName, \nor a custom function can be used for more control:\n\n++++++++++++++++++++++++++++++++++++++++\nINSTANTIATE_TEST_SUITE_P(\n    MyInstantiation, MyTestSuite,\n    ::testing:Values(...),\n    [](const ::testing:TestParamInfo<MyTestSuite::ParamType>& info) {\n      // Can use info.param here to generate the test suffix\n      std::string name = ...\n      return name;\n    });\n----------------------------------------\n\nFor more information, see Value-Parameterized \nTests.\n\nSee also GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST. \n"
	},
	"TYPED_TEST_SUITE": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TYPED_TEST_SUITE",
		"body":[
			"TYPED_TEST_SUITE(${1:TestFixtureName},${2:Types})"
		],
		"description":"Defines a typed test suite based on the test fixture TestFixtureName. \nThe test suite name is TestFixtureName.\n\nThe argument TestFixtureName is a fixture \nclass template, parameterized by a type, for example:\n\n++++++++++++++++++++++++++++++++++++++++\ntemplate <typename T>\nclass MyFixture : public ::testing:Test {\n public:\n  ...\n  using List = std::list<T>;\n  static T shared_;\n  T value_;\n};\n----------------------------------------\n\nThe argument Types is a Types object representing \nthe list of types to run the tests on, for example:\n\n++++++++++++++++++++++++++++++++++++++++\nusing MyTypes = ::testing:Types<char, int, unsigned int>;\nTYPED_TEST_SUITE(MyFixture, MyTypes);\n----------------------------------------\n\nThe type alias (using or typedef) is necessary for \nthe TYPED_TEST_SUITE macro to parse correctly.\n\nSee also TYPED_TEST and Typed Tests for more information. \n\n"
	},
	"TYPED_TEST": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TYPED_TEST",
		"body":[
			"TYPED_TEST( ${1:TestSuiteName}, ${2:TestName})\n{\n$3\n}"
		],
		"description":"Defines an individual typed test named TestName in the typed \ntest suite TestSuiteName. The test suite must be defined with \nTYPED_TEST_SUITE.\n\nWithin the test body, the special name \nTypeParam refers to the type parameter, and TestFixture refers \nto the fixture class. See the following example:\n\n++++++++++++++++++++++++++++++++++++++++\nTYPED_TEST(MyFixture, Example) {\n  // Inside a test, refer to the special name TypeParam to get the type\n  // parameter.  Since we are inside a derived class template, C++ requires\n  // us to visit the members of MyFixture via 'this'.\n  TypeParam n = this->value_;\n\n  // To visit static members of the fixture, add the 'TestFixture::'\n  // prefix.\n  n += TestFixture::shared_;\n\n  // To refer to typedefs in the fixture, add the 'typename TestFixture::'\n  // prefix. The 'typename' is required to satisfy the compiler.\n  typename TestFixture::List values;\n\n  values.push_back(n);\n  ...\n}\n----------------------------------------\n\nFor more information, see Typed Tests. "
	},
	"TYPED_TEST_SUITE_P": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TYPED_TEST_SUITE_P",
		"body":[
			"TYPED_TEST_SUITE_P(${1:TestFixtureName})"
		],
		"description":"Defines a type-parameterized test suite based on the test fixture \nTestFixtureName. The test suite name is TestFixtureName.\n\nThe argument TestFixtureName is a fixture \nclass template, parameterized by a type. See TYPED_TEST_SUITE \nfor an example.\n\nSee also TYPED_TEST_P and Type-Parameterized Tests \nfor more information. "
	},
	"TYPED_TEST_P": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TYPED_TEST_P",
		"body":[
			"TYPED_TEST_P( ${1:TestSuiteName}, ${2:TestName})\n{\n$3\n}"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nTYPED_TEST_P(TestSuiteName, TestName) {\n  ... statements ...\n}\n----------------------------------------\n\nDefines an individual type-parameterized test named TestName \nin the type-parameterized test suite TestSuiteName. The test \nsuite must be defined with TYPED_TEST_SUITE_P.\n\nWithin the test body, the special name \nTypeParam refers to the type parameter, and TestFixture refers \nto the fixture class. See TYPED_TEST for an example.\n\nSee also REGISTER_TYPED_TEST_SUITE_P and Type-Parameterized \nTests for more information. "
	},
	"REGISTER_TYPED_TEST_SUITE_P": {
		"scope": "c,cpp",
		"prefix": "g:Testing:REGISTER_TYPED_TEST_SUITE_P",
		"body":[
			"REGISTER_TYPED_TEST_SUITE_P( ${1:TestSuiteName}, ${2:TestNames})\n{\n$3\n}"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nREGISTER_TYPED_TEST_SUITE_P(TestSuiteName,TestNames...)\n----------------------------------------\n\nRegisters the type-parameterized tests TestNames... of \nthe test suite TestSuiteName. The test suite and tests must be \ndefined with TYPED_TEST_SUITE_P and TYPED_TEST_P.\n\nFor example:\n\n++++++++++++++++++++++++++++++++++++++++\n// Define the test suite and tests.\nTYPED_TEST_SUITE_P(MyFixture);\nTYPED_TEST_P(MyFixture, HasPropertyA) { ... }\nTYPED_TEST_P(MyFixture, HasPropertyB) { ... }\n\n// Register the tests in the test suite.\nREGISTER_TYPED_TEST_SUITE_P(MyFixture, HasPropertyA, HasPropertyB);\n----------------------------------------\n\nSee also INSTANTIATE_TYPED_TEST_SUITE_P and \nType-Parameterized Tests for more information. "
	},
	"INSTANTIATE_TYPED_TEST_SUITE_P": {
		"scope": "c,cpp",
		"prefix": "g:Testing:INSTANTIATE_TYPED_TEST_SUITE_P",
		"body":[
			"INSTANTIATE_TYPED_TEST_SUITE_P( ${1:InstantiationName}, ${2:TestSuiteName}, ${3:Types})"
		],
		"description":"Instantiates the type-parameterized test suite TestSuiteName. \nThe test suite must be registered with REGISTER_TYPED_TEST_SUITE_P.\n\nThe argument InstantiationName \nis a unique name for the instantiation of the test suite, to distinguish \nbetween multiple instantiations. In test output, the instantiation \nname is added as a prefix to the test suite name TestSuiteName.\n\nThe argument Types is a Types object representing \nthe list of types to run the tests on, for example:\n\n++++++++++++++++++++++++++++++++++++++++\nusing MyTypes = ::testing:Types<char, int, unsigned int>;\nINSTANTIATE_TYPED_TEST_SUITE_P(MyInstantiation, MyFixture, MyTypes);\n----------------------------------------\n\nThe type alias (using or typedef) is necessary for \nthe INSTANTIATE_TYPED_TEST_SUITE_P macro to parse correctly.\n\nFor more information, see Type-Parameterized \nTests. "
	},
	"FRIEND_TEST": {
		"scope": "c,cpp",
		"prefix": "g:Testing:FRIEND_TEST",
		"body":[
			"FRIEND_TEST(${1:TestSuiteName},${2:TestName})"
		],
		"description":"Within a class body, declares an individual test as a friend of \nthe class, enabling the test to access private class members.\n\nIf the class is defined in a namespace, then in order \nto be friends of the class, test fixtures and tests must be defined \nin the exact same namespace, without inline or anonymous namespaces.\n\nFor example, if the class definition looks like \nthe following:\n\n++++++++++++++++++++++++++++++++++++++++\nnamespace my_namespace {\nclass MyClass {\n  friend class MyClassTest;\n  FRIEND_TEST(MyClassTest, HasPropertyA);\n  FRIEND_TEST(MyClassTest, HasPropertyB);\n  ... definition of class MyClass ...\n};\n\n}  // namespace my_namespace\n----------------------------------------\n\nThen the test code should look like:\n\n++++++++++++++++++++++++++++++++++++++++\nnamespace my_namespace {\nclass MyClassTest : public ::testing:Test {\n  ...\n};\n\nTEST_F(MyClassTest, HasPropertyA) { ... }\nTEST_F(MyClassTest, HasPropertyB) { ... }\n\n}  // namespace my_namespace\n----------------------------------------\n\nSee Testing Private Code for more information. "
	},
	"SCOPED_TRACE": {
		"scope": "c,cpp",
		"prefix": "g:Testing:SCOPED_TRACE",
		"body":[
			"SCOPED_TRACE(${1:message})"
		],
		"description":"Causes the current file name, line number, and the given message \nmessage to be added to the failure message for each assertion \nfailure that occurs in the scope.\n\nFor more information, see Adding Traces to Assertions.\n\nSee also the ScopedTrace class.  "
	},
	"GTEST_SKIP": {
		"scope": "c,cpp",
		"prefix": "g:Testing:GTEST_SKIP",
		"body":[
			"GTEST_SKIP()"
		],
		"description":"Prevents further test execution at runtime.\n\nCan be used in individual test cases or in the SetUp() \nmethods of test environments or test fixtures (classes derived \nfrom the Environment or Test classes). If used in a global test \nenvironment SetUp() method, it skips all tests in the test program. \nIf used in a test fixture SetUp() method, it skips all tests in \nthe corresponding test suite.\n\nSimilar to assertions, GTEST_SKIP allows streaming \na custom message into it.\n\nSee Skipping Test Execution for more information. "
	},

	"GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST": {
		"scope": "c,cpp",
		"prefix": "g:Testing:GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST",
		"body":[
			"GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST(${1:TestSuiteName})"
		],
		"description":"Allows the value-parameterized test suite TestSuiteName to \nbe uninstantiated.\n\nBy default, every TEST_P call without a corresponding \nINSTANTIATE_TEST_SUITE_P call causes a failing test in the \ntest suite GoogleTestVerification. GTEST_ALLOW_UNINSTANTIATED_PARAMETERIZED_TEST \nsuppresses this failure for the given test suite. "
	},

	"AssertionResult": {
		"scope": "c,cpp",
		"prefix": "g:Testing:AssertionResult",
		"body":[
			"AssertionResult()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n::testing::AssertionResult\n----------------------------------------\n\nA class for indicating whether an assertion was successful.\n\nWhen the assertion wasnбпt successful, the AssertionResult \nobject stores a non-empty failure message that can be retrieved \nwith the objectбпs message() method.\n\nTo create an instance of this class, use one of the factory \nfunctions AssertionSuccess() or AssertionFailure(). "
	},
	"AssertionFailure": {
		"scope": "c,cpp",
		"prefix": "g:Testing:AssertionFailure",
		"body":[
			"AssertionFailure()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n::testing::AssertionFailure\n----------------------------------------\n\nA class for indicating whether an assertion was successful.\n\nWhen the assertion wasnбпt successful, the AssertionResult \nobject stores a non-empty failure message that can be retrieved \nwith the objectбпs message() method.\n\nTo create an instance of this class, use one of the factory \nfunctions AssertionSuccess() or AssertionFailure(). "
	},

	"AssertionException": {
		"scope": "c,cpp",
		"prefix": "g:Testing:AssertionException",
		"body":[
			"AssertionException()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n::testing::AssertionException\n----------------------------------------\n\nException which can be thrown from TestEventListener::OnTestPartResult. \n"
	},

	"EmptyTestEventListener": {
		"scope": "c,cpp",
		"prefix": "g:Testing:EmptyTestEventListener",
		"body":[
			"EmptyTestEventListener()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n::testing::EmptyTestEventListener\n----------------------------------------\n\nProvides an empty implementation of all methods in the TestEventListener \ninterface, such that a subclass only needs to override the methods \nit cares about. "
	},

	"Environment": {
		"scope": "c,cpp",
		"prefix": "g:Testing:Environment",
		"body":[
			"Environment"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n::testing::Environment\n----------------------------------------\n\nRepresents a global test environment. See Global Set-Up \nand Tear-Down. "
	},

	"ScopedTrace": {
		"scope": "c,cpp",
		"prefix": "g:Testing:ScopedTrace",
		"body":[
			"ScopedTrace trace(${1:file}, ${2:line},${3:message});"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n::testing::ScopedTrace\n----------------------------------------\n\nAn instance of this class causes a trace to be included in every \ntest failure message generated by code in the scope of the lifetime \nof the ScopedTrace instance. The effect is undone with the destruction \nof the instance.\n\nThe ScopedTrace constructor has the following \nform:\n\n++++++++++++++++++++++++++++++++++++++++\ntemplate <typename T>\nScopedTrace(const char* file, int line, const T& message)\n----------------------------------------\n\nExample usage:\n\n++++++++++++++++++++++++++++++++++++++++\n::testing::ScopedTrace trace(\"file.cc\", 123, \"message\");\n----------------------------------------\n\nThe resulting trace includes the given source file \npath and line number, and the given message. The message argument \ncan be anything streamable to std::ostream.\n\nSee also SCOPED_TRACE. "
	},

	"SetUpTestSuite": {
		"scope": "c,cpp",
		"prefix": "g:Testing:SetUpTestSuite",
		"body":[
			"Test::SetUpTestSuite()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nstatic void Test::SetUpTestSuite()\n----------------------------------------\n\nPerforms shared setup for all tests in the test suite. GoogleTest \ncalls SetUpTestSuite() before running the first test in the \ntest suite. "
	},

	"TearDownTestSuite": {
		"scope": "c,cpp",
		"prefix": "g:Testing:TearDownTestSuite()",
		"body":[
			"Test::TearDownTestSuite()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nstatic void Test::TearDownTestSuite()\n----------------------------------------\n\nPerforms shared teardown for all tests in the test suite. \nGoogleTest calls TearDownTestSuite() after running the last \ntest in the test suite. "
	},

	"HasFatalFailure": {
		"scope": "c,cpp",
		"prefix": "g:Testing:HasFatalFailure()",
		"body":[
			"Test::HasFatalFailure()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nstatic bool Test::HasFatalFailure()\n----------------------------------------\n\nReturns true if and only if the current test has a fatal failure. \n"
	},

	"HasNonfatalFailure": {
		"scope": "c,cpp",
		"prefix": "g:Testing:HasNonfatalFailure()",
		"body":[
			"Test::HasNonfatalFailure()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nstatic bool Test::HasNonfatalFailure()\n----------------------------------------\n\nReturns true if and only if the current test has a nonfatal \nfailure. "
	},

	"HasFailure": {
		"scope": "c,cpp",
		"prefix": "g:Testing:HasFailure()",
		"body":[
			"Test::HasFailure()"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nstatic bool Test::HasFailure()\n----------------------------------------\n\nReturns true if and only if the current test has any failure, \neither fatal or nonfatal. "
	},

	"IsSkipped": {
		"scope": "c,cpp",
		"prefix": "g:Testing:IsSkipped",
		"body":[
			"Test::IsSkipped()"
		],
		"description":"Returns true if and only if the current test was skipped."
	},
	"RecordProperty": {
		"scope": "c,cpp",
		"prefix": "g:Testing:RecordProperty",
		"body":[
			"Test::RecordProperty(${1:key},${2:value})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nstatic void Test::RecordProperty(const std::string& key, const std::string& value)\nstatic void Test::RecordProperty(const std::string& key, int value)\n----------------------------------------\n\nLogs a property for the current test, test suite, or entire \ninvocation of the test program. Only the last value for a given \nkey is logged.\n\nThe key must be a valid XML attribute name, and cannot \nconflict with the ones already used by GoogleTest (name, status, \ntime, classname, type_param, and value_param).\n\nRecordProperty is public static so it can be \ncalled from utility functions that are not members of the test \nfixture.\n\nCalls to RecordProperty made during the lifespan \nof the test (from the moment its constructor starts to the moment \nits destructor finishes) are output in XML as attributes of the \n<testcase> element. Properties recorded from a fixture��s SetUpTestSuite \nor TearDownTestSuite methods are logged as attributes of the \ncorresponding <testsuite> element. Calls to RecordProperty \nmade in the global context (before or after invocation of RUN_ALL_TESTS \nor from the SetUp/TearDown methods of registered Environment \nobjects) are output as attributes of the <testsuites> element. \n"
	},

	"MOCK_METHOD": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:MOCK_METHOD",
		"body":[
			"MOCK_METHOD(${1:return_type},${2:method_name}, (${3:args}))"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nMOCK_METHOD(return_type,method_name, (args...));\nMOCK_METHOD(return_type,method_name, (args...), (specs...));\n----------------------------------------\n\nDefines a mock method method_name with arguments (args...) \nand return type return_type within a mock class.\n\nThe parameters of MOCK_METHOD mirror the method declaration. \nThe optional fourth parameter specs... is a comma-separated \nlist of qualifiers. The following qualifiers are accepted:\n\n++++++++++++++++++++++++++++++++++++++++\nQualifier        Meaning\nconst              Makes the mocked method a const method. Required if overriding a const method.\noverride          Marks the method with override. Recommended if overriding a virtual method.\nnoexcept          Marks the method with noexcept. Required if overriding a noexcept method.\nCalltype(calltype)Sets the call type for the method, for example Calltype(STDMETHODCALLTYPE). Useful on Windows.\nref(qualifier)    Marks the method with the given reference qualifier, for example ref(&) or ref(&&). Required if overriding a method that has a reference qualifier.\n----------------------------------------\n\nNote that commas in arguments prevent MOCK_METHOD \nfrom parsing the arguments correctly if they are not appropriately \nsurrounded by parentheses. See the following example:\n\n++++++++++++++++++++++++++++++++++++++++\nclass MyMock {\n public:\n  // The following 2 lines will not compile due to commas in the arguments:\n  MOCK_METHOD(std::pair<bool, int>, GetPair, ());              // Error!\n  MOCK_METHOD(bool, CheckMap, (std::map<int, double>, bool));  // Error!\n\n  // One solution - wrap arguments that contain commas in parentheses:\n  MOCK_METHOD((std::pair<bool, int>), GetPair, ());\n  MOCK_METHOD(bool, CheckMap, ((std::map<int, double>), bool));\n\n  // Another solution - use type aliases:\n  using BoolAndInt = std::pair<bool, int>;\n  MOCK_METHOD(BoolAndInt, GetPair, ());\n  using MapIntDouble = std::map<int, double>;\n  MOCK_METHOD(bool, CheckMap, (MapIntDouble, bool));\n};\n----------------------------------------\n\nMOCK_METHOD must be used in the public: section \nof a mock class definition, regardless of whether the method \nbeing mocked is public, protected, or private in the base class. \n"
	},

	"EXPECT_CALL": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL",
		"body":[
			"EXPECT_CALL( ${1:mock_object}, ${2:method_name})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nEXPECT_CALL(mock_object,method_name(matchers...))\n----------------------------------------\n\nCreates an expectation that the method method_name of the \nobject mock_object is called with arguments that match the given \nmatchers matchers.... EXPECT_CALL must precede any code that \nexercises the mock object.\n\nThe parameter matchers... is a comma-separated list \nof matchers that correspond to each argument of the method method_name. \nThe expectation will apply only to calls of method_name whose \narguments match all of the matchers. If (matchers...) is omitted, \nthe expectation behaves as if each argument's matcher were a \nwildcard matcher (_). See the Matchers Reference for a list of \nall built-in matchers.\n\nThe following chainable clauses can be used to modify \nthe expectation, and they must be used in the following order:\n\n++++++++++++++++++++++++++++++++++++++++\nEXPECT_CALL(mock_object, method_name(matchers...))\n    .With(multi_argument_matcher)  // Can be used at most once\n    .Times(cardinality)            // Can be used at most once\n    .InSequence(sequences...)      // Can be used any number of times\n    .After(expectations...)        // Can be used any number of times\n    .WillOnce(action)              // Can be used any number of times\n    .WillRepeatedly(action)        // Can be used at most once\n    .RetiresOnSaturation();        // Can be used at most once\n----------------------------------------\n\n "
	},
	"EXPECT_CALL.With": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.With",
		"body":[
			".With( ${1:multi_argument_matcher})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n.With(multi_argument_matcher)\n----------------------------------------\n\nRestricts the expectation to apply only to mock function \ncalls whose arguments as a whole match the multi-argument matcher \nmulti_argument_matcher.\n\nGoogleTest passes all of the arguments \nas one tuple into the matcher. The parameter multi_argument_matcher \nmust thus be a matcher of type Matcher<std::tuple<A1, ..., An>>, \nwhere A1, ..., An are the types of the function arguments.\n\nFor example, the following code sets the expectation \nthat my_mock.SetPosition() is called with any two arguments, \nthe first argument being less than the second:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::_;\nusing ::testing::Lt;\n...\nEXPECT_CALL(my_mock, SetPosition(_, _))\n    .With(Lt());\n----------------------------------------\n\nGoogleTest provides some built-in matchers for \n2-tuples, including the Lt() matcher above. See Multi-argument \nMatchers.\n\nThe With clause can be used at most once on an expectation \nand must be the first clause. "
	},
	"EXPECT_CALL.Times": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.Times",
		"body":[
			".Times( ${1:cardinality})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n.Times(cardinality)\n----------------------------------------\n\nSpecifies how many times the mock function call is expected.\n\nThe parameter cardinality represents the number \nof expected calls and can be one of the following, all defined \nin the ::testing namespace:\n\n++++++++++++++++++++++++++++++++++++++++\nCardinalityMeaning\nAnyNumber()    The function can be called any number of times.\nAtLeast(n)    The function call is expected at least n times.\nAtMost(n)    The function call is expected at most n times.\nBetween(m, n)The function call is expected between m and n times, inclusive.\nExactly(n) or nThe function call is expected exactly n times. If n is 0, the call should never happen.\n----------------------------------------\n\nIf the Times clause is omitted, GoogleTest infers \nthe cardinality as follows:\n\nIf neither WillOnce nor WillRepeatedly are specified, \nthe inferred cardinality is Times(1).If there are n WillOnce \nclauses and no WillRepeatedly clause, where n >= 1, the inferred \ncardinality is Times(n).If there are n WillOnce clauses and \none WillRepeatedly clause, where n >= 0, the inferred cardinality \nis Times(AtLeast(n)).The Times clause can be used at most once \non an expectation. "
	},
	"EXPECT_CALL.InSequence": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.InSequence",
		"body":[
			".InSequence(${1:sequences})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\n.InSequence(sequences...)\n----------------------------------------\n\nSpecifies that the mock function call is expected in a certain \nsequence.\n\nThe parameter sequences... is any number of Sequence \nobjects. Expected calls assigned to the same sequence are expected \nto occur in the order the expectations are declared.\n\nFor example, the following code sets the expectation \nthat the Reset() method of my_mock is called before both GetSize() \nand Describe(), and GetSize() and Describe() can occur in any \norder relative to each other:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::Sequence;\nSequence s1, s2;\n...\nEXPECT_CALL(my_mock, Reset())\n    .InSequence(s1, s2);\nEXPECT_CALL(my_mock, GetSize())\n    .InSequence(s1);\nEXPECT_CALL(my_mock, Describe())\n    .InSequence(s2);\n----------------------------------------\n\nThe InSequence clause can be used any number of times \non an expectation.\n\nSee also the InSequence class. "
	},

	"EXPECT_CALL.After": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.After",
		"body":[
			"After(${1:expectations})"
		],
		"description":".After(expectations...)\n\nSpecifies that the mock function \ncall is expected to occur after one or more other calls.\n\nThe parameter expectations... can be up to five Expectation \nor ExpectationSet objects. The mock function call is expected \nto occur after all of the given expectations.\n\nFor example, the following code sets the expectation \nthat the Describe() method of my_mock is called only after both \nInitX() and InitY() have been called.\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::Expectation;\n...\nExpectation init_x = EXPECT_CALL(my_mock, InitX());\nExpectation init_y = EXPECT_CALL(my_mock, InitY());\nEXPECT_CALL(my_mock, Describe())\n    .After(init_x, init_y);\n----------------------------------------\n\nThe ExpectationSet object is helpful when the number \nof prerequisites for an expectation is large or variable, for \nexample:\n\nusing ::testing::ExpectationSet;...ExpectationSet \nall_inits;\n\n++++++++++++++++++++++++++++++++++++++++\n// Collect all expectations of InitElement() calls\nfor (int i = 0; i < element_count; i++) {\n  all_inits += EXPECT_CALL(my_mock, InitElement(i));\n}\nEXPECT_CALL(my_mock, Describe())\n    .After(all_inits);\n----------------------------------------\n\n    // Expect Describe() call after all InitElement() \ncallsThe After clause can be used any number of times on an expectation. \n"
	},

	"EXPECT_CALL.WillOnce": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.WillOnce",
		"body":[
			".WillOnce(${1:action})"
		],
		"description":".WillOnce(action)\n\nSpecifies the mock function’s actual \nbehavior when invoked, for a single matching function call.\n\nThe parameter action represents the action that the \nfunction call will perform. See the Actions Reference for a list \nof built-in actions.\n\nThe use of WillOnce implicitly sets a cardinality \non the expectation when Times is not specified. See Times.\n\nEach matching function call will perform the next action \nin the order declared. For example, the following code specifies \nthat my_mock.GetNumber() is expected to be called exactly 3 \ntimes and will return 1, 2, and 3 respectively on the first, second, \nand third calls:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::Return;\n...\nEXPECT_CALL(my_mock, GetNumber())\n    .WillOnce(Return(1))\n    .WillOnce(Return(2))\n    .WillOnce(Return(3));\n----------------------------------------\n\nThe WillOnce clause can be used any number of times \non an expectation. "
	},
	"EXPECT_CALL.WillRepeatedly": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.WillRepeatedly",
		"body":[
			".WillRepeatedly(${1:action})"
		],
		"description":".WillRepeatedly(action)\n\nSpecifies the mock function’s \nactual behavior when invoked, for all subsequent matching function \ncalls. Takes effect after the actions specified in the WillOnce \nclauses, if any, have been performed.\n\nThe parameter action represents the action that \nthe function call will perform. See the Actions Reference for \na list of built-in actions.\n\nThe use of WillRepeatedly implicitly sets a cardinality \non the expectation when Times is not specified. See Times.\n\nIf any WillOnce clauses have been specified, matching \nfunction calls will perform those actions before the action \nspecified by WillRepeatedly. See the following example:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::Return;\n...\nEXPECT_CALL(my_mock, GetName())\n    .WillRepeatedly(Return(\"John Doe\"));  // Return \"John Doe\" on all calls\n\nEXPECT_CALL(my_mock, GetNumber())\n    .WillOnce(Return(42))        // Return 42 on the first call\n    .WillRepeatedly(Return(7));  // Return 7 on all subsequent calls\n----------------------------------------\n\nThe WillRepeatedly clause can be used at most once \non an expectation. "
	},
	"EXPECT_CALL.RetiresOnSaturation": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:EXPECT_CALL.RetiresOnSaturation",
		"body":[
			".RetiresOnSaturation()"
		],
		"description":".RetiresOnSaturation()\n\nIndicates that the expectation \nwill no longer be active after the expected number of matching \nfunction calls has been reached.\n\nThe RetiresOnSaturation clause is only meaningful \nfor expectations with an upper-bounded cardinality. The expectation \nwill retire (no longer match any function calls) after it has \nbeen saturated (the upper bound has been reached). See the following \nexample:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::_;\nusing ::testing::AnyNumber;\n...\nEXPECT_CALL(my_mock, SetNumber(_))  // Expectation 1\n    .Times(AnyNumber());\nEXPECT_CALL(my_mock, SetNumber(7))  // Expectation 2\n    .Times(2)\n    .RetiresOnSaturation();\n----------------------------------------\n\nIn the above example, the first two calls to my_mock.SetNumber(7) \nmatch expectation 2, which then becomes inactive and no longer \nmatches any calls. A third call to my_mock.SetNumber(7) would \nthen match expectation 1. Without RetiresOnSaturation() on \nexpectation 2, a third call to my_mock.SetNumber(7) would match \nexpectation 2 again, producing a failure since the limit of 2 \ncalls was exceeded.\n\nThe RetiresOnSaturation clause can be used at most \nonce on an expectation and must be the last clause. "
	},
	"ON_CALL": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:ON_CALL",
		"body":[
			"ON_CALL(${1:mock_object}, ${2:method_name})"
		],
		"description":"ON_CALL(mock_object,method_name(matchers...))\n\nDefines \nwhat happens when the method method_name of the object mock_object \nis called with arguments that match the given matchers matchers.... \nRequires a modifier clause to specify the method’s behavior. \nDoes not set any expectations that the method will be called.\n\nThe parameter matchers... is a comma-separated list \nof matchers that correspond to each argument of the method method_name. \nThe ON_CALL specification will apply only to calls of method_name \nwhose arguments match all of the matchers. If (matchers...) \nis omitted, the behavior is as if each argument’s matcher were \na wildcard matcher (_). See the Matchers Reference for a list \nof all built-in matchers.\n\nThe following chainable clauses can be used to set \nthe method’s behavior, and they must be used in the following \norder:\n\n++++++++++++++++++++++++++++++++++++++++\nON_CALL(mock_object, method_name(matchers...))\n    .With(multi_argument_matcher)  // Can be used at most once\n    .WillByDefault(action);        // Required\n----------------------------------------\n\nSee details for each modifier clause below. "
	},
	"ON_CALL.With": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:ON_CALL.With",
		"body":[
			".With(${1:multi_argument_matcher})"
		],
		"description":".With(multi_argument_matcher)\n\nRestricts the specification \nto only mock function calls whose arguments as a whole match the \nmulti-argument matcher multi_argument_matcher.\n\nGoogleTest passes all of the arguments \nas one tuple into the matcher. The parameter multi_argument_matcher \nmust thus be a matcher of type Matcher<std::tuple<A1, ..., An>>, \nwhere A1, ..., An are the types of the function arguments.\n\nFor example, the following code sets the default \nbehavior when my_mock.SetPosition() is called with any two \narguments, the first argument being less than the second:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::_;\nusing ::testing::Lt;\nusing ::testing::Return;\n...\nON_CALL(my_mock, SetPosition(_, _))\n    .With(Lt())\n    .WillByDefault(Return(true));\n----------------------------------------\n\nGoogleTest provides some built-in matchers for \n2-tuples, including the Lt() matcher above. See Multi-argument \nMatchers.\n\nThe With clause can be used at most once with each \nON_CALL statement. "
	},
	"ON_CALL.WillByDefault": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:ON_CALL.WillByDefault",
		"body":[
			".WillByDefault(${1:action})"
		],
		"description":".WillByDefault(action)\n\nSpecifies the default behavior \nof a matching mock function call.\n\nThe parameter action represents the action that the \nfunction call will perform. See the Actions Reference for a list \nof built-in actions.\n\nFor example, the following code specifies that by \ndefault, a call to my_mock.Greet() will return \"hello\":\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::Return;\n...\nON_CALL(my_mock, Greet())\n    .WillByDefault(Return(\"hello\"));\n----------------------------------------\n\n    The action specified by WillByDefault is superseded \nby the actions specified on a matching EXPECT_CALL statement, \nif any. See the WillOnce and WillRepeatedly clauses of EXPECT_CALL.\n\nThe WillByDefault clause must be used exactly \nonce with each ON_CALL statement. "
	},
	"DefaultValue": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:DefaultValue",
		"body":[
			"DefaultValue<T>::Set(${1:value});"
		],
		"description":"::testing::DefaultValue<T>\n\nAllows a user to specify the \ndefault value for a type T that is both copyable and publicly destructible \n(i.e. anything that can be used as a function return type). For \nmock functions with a return type of T, this default value is returned \nfrom function calls that do not specify an action.\n\nProvides the static methods Set(), SetFactory(), \nand Clear() to manage the default value:\n\n++++++++++++++++++++++++++++++++++++++++\n// Sets the default value to be returned. T must be copy constructible.\nDefaultValue<T>::Set(value);\n\n// Sets a factory. Will be invoked on demand. T must be move constructible.\nT MakeT();\nDefaultValue<T>::SetFactory(&MakeT);\n\n// Unsets the default value.\nDefaultValue<T>::Clear();\n----------------------------------------\n\n "
	},
	"InSequence": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:InSequence",
		"body":[
			"InSequence seq;"
		],
		"description":":testing::InSequence\n\nAn object of this type causes all expectations \nencountered in its scope to be put in an anonymous sequence.\n\nThis allows more convenient expression of multiple \nexpectations in a single sequence:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::InSequence;\n{\n  InSequence seq;\n\n  // The following are expected to occur in the order declared.\n  EXPECT_CALL(...);\n  EXPECT_CALL(...);\n  ...\n  EXPECT_CALL(...);\n}\n----------------------------------------\n\nThe name of the InSequence object does not matter. \n"
	},
	"Expectation": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:Expectation",
		"body":[
			"Expectation my_expectation = EXPECT_CALL(${1:expectation});"
		],
		"description":"::testing::Expectation\n\nRepresents a mock function call \nexpectation as created by EXPECT_CALL:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::Expectation;\nExpectation my_expectation = EXPECT_CALL(...);\n----------------------------------------\n\nUseful for specifying sequences of expectations; \nsee the After clause of EXPECT_CALL. "
	},
	"ExpectationSet": {
		"scope": "c,cpp",
		"prefix": "g:Mocking:ExpectationSet",
		"body":[
			"ExpectationSet my_expectations;\nmy_expectations += EXPECT_CALL(${1:expectation});"
		],
		"description":"::testing::ExpectationSet\n\nRepresents a set of mock function \ncall expectations.\n\nUse the += operator to add Expectation objects \nto the set:\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::ExpectationSet;\nExpectationSet my_expectations;\nmy_expectations += EXPECT_CALL(...);\n----------------------------------------\n\nUseful for specifying sequences of expectations; see \nthe After clause of EXPECT_CALL. "
	},

	//Assertions https://google.github.io/googletest/reference/assertions.html
	"SUCCEED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:SUCCEED",
		"body":[
			"SUCCEED()"
		],
		"description":"SUCCEED()\n\nGenerates a success. This does not make the overall \ntest succeed. A test is considered successful only if none of \nits assertions fail during its execution.\n\nThe SUCCEED assertion is purely documentary and \ncurrently doesnt generate any usser-visible output. However, \nwe may add SUCCEED messages to GoogleTest output in the future. \n"
	},
	"FAIL": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:FAIL",
		"body":[
			"FAIL()"
		],
		"description":"FAIL()\n\nGenerates a fatal failure, which returns from the current \nfunction.\n\nCan only be used in functions that return void. See \nAssertion Placement for more information.Explicit Success \nand FailureThe assertions in this section generate a success \nor failure directly instead of testing a value or expression. \nThese are useful when control flow, rather than a Boolean expression, \ndetermines the test��s success or failure, as shown by the following \nexample:\n\n++++++++++++++++++++++++++++++++++++++++\nswitch(expression) {\n  case 1:\n    ... some checks ...\n  case 2:\n    ... some other checks ...\n  default:\n    FAIL() << \"We shouldn't get here.\";\n}\n----------------------------------------\n\n "
	},
	"ADD_FAILURE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ADD_FAILURE",
		"body":[
			"ADD_FAILURE()"
		],
		"description":"ADD_FAILURE()\n\nGenerates a nonfatal failure, which allows \nthe current function to continue running. "
	},
    "ADD_FAILURE_AT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ADD_FAILURE_AT",
		"body":[
			"ADD_FAILURE_AT(${1:file_path},${2:line_number})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nADD_FAILURE_AT(file_path,line_number)\n----------------------------------------\n\nGenerates a nonfatal failure at the file and line number specified. \n"
	},
    //Generalized Assertion https://google.github.io/googletest/reference/assertions.html#generalized
	"EXPECT_THAT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_THAT",
		"body":[
			"EXPECT_THAT(${1:value},${2:matcher})"
		],
		"description":"EXPECT_THAT(value,matcher)ASSERT_THAT(value,matcher)\n\nVerifies \nthat value matches the matcher matcher.\n\nFor example, the following code verifies that the \nstring value1 starts with \"Hello\", value2 matches a regular \nexpression, and value3 is between 5 and 10:\n\n#include \"gmock/gmock.h\"\n\n++++++++++++++++++++++++++++++++++++++++\nusing ::testing::AllOf;\nusing ::testing::Gt;\nusing ::testing::Lt;\nusing ::testing::MatchesRegex;\nusing ::testing::StartsWith;\n\n...\nEXPECT_THAT(value1, StartsWith(\"Hello\"));\nEXPECT_THAT(value2, MatchesRegex(\"Line \\d+\"));\nASSERT_THAT(value3, AllOf(Gt(5), Lt(10)));\n----------------------------------------\n\nMatchers enable assertions of this form \nto read like English and generate informative failure messages. \nFor example, if the above assertion on value1 fails, the resulting \nmessage will be similar to the following:\n\nValue of: value1  Actual: \"Hi, world!\"Expected: \nstarts with \"Hello\"GoogleTest provides a built-in library \nof matchers��see the Matchers Reference. It is also possible \nto write your own matchers��see Writing New Matchers Quickly. \nThe use of matchers makes EXPECT_THAT a powerful, extensible \nassertion.\n\nThe idea for this assertion was borrowed from Joe \nWalnes Hamcrest project, which adds assertThat() to JUnit. \n"
	},
	"ASSERT_THAT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_THAT",
		"body":[
			"ASSERT_THAT(${1:value},${2:matcher})"
		],
		"description":"ASSERT_THAT(value,matcher)"
	},
    //Boolean Conditions https://google.github.io/googletest/reference/assertions.html#boolean
	"EXPECT_TRUE": {
			"scope": "c,cpp",
			"prefix": "g:Assertions:EXPECT_TRUE",
			"body":[
				"EXPECT_TRUE(${1:condition})"
			],
			"description":"Verifies that condition is true."
	},
	"ASSERT_TRUE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_TRUE",
		"body":[
			"ASSERT_TRUE(${1:condition})"
		],
		"description":"Verifies that condition is true."
	},
	"EXPECT_FALSE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_FALSE",
		"body":[
			"EXPECT_FALSE(${1:condition})"
		],
		"description":"Verifies that condition is false."
	},
	
	"ASSERT_FALSE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_FALSE",
		"body":[
			"ASSERT_FALSE(${1:condition})"
		],
		"description":"Verifies that condition is false."
	},
    //Binary Comparison   https://google.github.io/googletest/reference/assertions.html#binary-comparison
	"EXPECT_EQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_EQ",
		"body":[
			"EXPECT_EQ($1,$2)"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nEXPECT_EQ(val1,val2)\nASSERT_EQ(val1,val2)\n----------------------------------------\n\nVerifies that val1==val2.\n\nDoes pointer equality on pointers. If used on \ntwo C strings, it tests if they are in the same memory location, \nnot if they have the same value. Use EXPECT_STREQ to compare C \nstrings (e.g. const char*) by value.\n\nWhen comparing a pointer to NULL, use EXPECT_EQ(ptr, \nnullptr) instead of EXPECT_EQ(ptr, NULL). "
	},
	"EXPECT_NE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_NE",
		"body":[
			"EXPECT_NE($1,$2)"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nEXPECT_NE(val1,val2)\nASSERT_NE(val1,val2)\n----------------------------------------\n\nVerifies that val1!=val2.\n\nDoes pointer equality on pointers. If used on \ntwo C strings, it tests if they are in different memory locations, \nnot if they have different values. Use EXPECT_STRNE to compare \nC strings (e.g. const char*) by value.\n\nWhen comparing a pointer to NULL, use EXPECT_NE(ptr, \nnullptr) instead of EXPECT_NE(ptr, NULL). "
	},
	"EXPECT_LT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_LT",
		"body":[
			"EXPECT_LT($1,$2)"
		],
		"description":"Verifies that val1<val2."
	},
	"EXPECT_LE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_LE",
		"body":[
			"EXPECT_LE($1,$2)"
		],
		"description":"Verifies that val1<=val2."
	},
	"EXPECT_GT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_GT",
		"body":[
			"EXPECT_GT($1,$2)"
		],
		"description":"Verifies that val1>val2."
	},
	"EXPECT_GE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_GE",
		"body":[
			"EXPECT_GE($1,$2)"
		],
		"description":"Verifies that val1>=val2."
	},
	"ASSERT_EQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_EQ",
		"body":[
			"ASSERT_EQ($1,$2)"
		],
		"description":"ASSERT_EQ(val1, val2)"
	},
	"ASSERT_NE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_NE",
		"body":[
			"ASSERT_NE($1,$2)"
		],
		"description":"ASSERT_NE(val1, val2)"
	},
	"ASSERT_LT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_LT",
		"body":[
			"ASSERT_LT($1,$2)"
		],
		"description":"ASSERT_LT(val1, val2)"
	},
	"ASSERT_LE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_LE",
		"body":[
			"ASSERT_LE($1,$2)"
		],
		"description":"ASSERT_LE(val1, val2)"
	},
	"ASSERT_GT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_GT",
		"body":[
			"ASSERT_GT($1,$2)"
		],
		"description":"ASSERT_GT(val1, val2)"
	},
	"ASSERT_GE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_GE",
		"body":[
			"ASSERT_GE($1,$2)"
		],
		"description":"ASSERT_GE(val1, val2)"
	},
    //String Comparison https://google.github.io/googletest/reference/assertions.html#c-strings
	"EXPECT_STREQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_STREQ",
		"body":[
			"EXPECT_STREQ($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have the same contents."
	},
	"ASSERT_STREQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_STREQ",
		"body":[
			"ASSERT_STREQ($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have the same contents."
	},
	"EXPECT_STRNE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_STRNE",
		"body":[
			"EXPECT_STRNE($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have different contents."
	},
	"ASSERT_STRNE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_STRNE",
		"body":[
			"ASSERT_STRNE($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have different contents."
	},
	"EXPECT_STRCASEEQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_STRCASEEQ",
		"body":[
			"EXPECT_STRCASEEQ($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have the same contents, ignoring case"
	},
	"ASSERT_STRCASEEQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_STRCASEEQ",
		"body":[
			"ASSERT_STRCASEEQ($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have the same contents, ignoring case"
	},
	"EXPECT_STRCASENE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_STRCASENE",
		"body":[
			"EXPECT_STRCASENE($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have different contents, ignoring case."
	},
	"ASSERT_STRCASENE": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_STRCASENE",
		"body":[
			"ASSERT_STRCASENE($1,$2)"
		],
		"description":"Verifies that the two C strings str1 and str2 have different contents, ignoring case."
	},

	"EXPECT_FLOAT_EQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_FLOAT_EQ",
		"body":[
			"EXPECT_FLOAT_EQ($1,$2)"
		],
		"description":"Verifies that the two float values val1 and val2 are approximately equal, to within 4 ULPs from each other."
	},
	"ASSERT_FLOAT_EQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_FLOAT_EQ",
		"body":[
			"ASSERT_FLOAT_EQ($1,$2)"
		],
		"description":"Verifies that the two float values val1 and val2 are approximately equal, to within 4 ULPs from each other."
	},
	"EXPECT_DOUBLE_EQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_DOUBLE_EQ",
		"body":[
			"EXPECT_DOUBLE_EQ($1,$2)"
		],
		"description":"Verifies that the two double values val1 and val2 are approximately equal, to within 4 ULPs from each other."
	},
	"ASSERT_DOUBLE_EQ": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_DOUBLE_EQ",
		"body":[
			"ASSERT_DOUBLE_EQ($1,$2)"
		],
		"description":"Verifies that the two double values val1 and val2 are approximately equal, to within 4 ULPs from each other."
	},
	"EXPECT_NEAR": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_NEAR",
		"body":[
			"EXPECT_NEAR($1,$2)"
		],
		"description":"Verifies that the difference between val1 and val2 does not exceed the absolute error bound abs_error."
	},
	"ASSERT_NEAR": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_NEAR",
		"body":[
			"ASSERT_NEAR($1,$2)"
		],
		"description":"Verifies that the difference between val1 and val2 does not exceed the absolute error bound abs_error."
	},
	"EXPECT_THROW": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_THROW",
		"body":[
			"EXPECT_THROW(${1:statement},${2s:exception_type})"
		],
		"description":"Verifies that statement throws an exception of type exception_type."
	},
	"ASSERT_THROW": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_THROW",
		"body":[
			"ASSERT_THROW(${1:statement},${2s:exception_type})"
		],
		"description":"Verifies that statement throws an exception of type exception_type."
	},
	"EXPECT_ANY_THROW": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_ANY_THROW",
		"body":[
			"EXPECT_ANY_THROW(${1:statement})"
		],
		"description":"Verifies that statement throws an exception of any type."
	},
	"ASSERT_ANY_THROW": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_ANY_THROW",
		"body":[
			"ASSERT_ANY_THROW(${1:statement})"
		],
		"description":"Verifies that statement throws an exception of any type."
	},
	"EXPECT_NO_THROW": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_NO_THROW",
		"body":[
			"EXPECT_NO_THROW(${1:statement})"
		],
		"description":"Verifies that statement does not throw any exception."
	},
	"ASSERT_NO_THROW": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_NO_THROW",
		"body":[
			"ASSERT_NO_THROW(${1:statement})"
		],
		"description":"Verifies that statement does not throw any exception."
	},
	//TODO EXPECT_PRED1 2 3
	"EXPECT_PRED1": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_PRED1",
		"body":[
			"EXPECT_PRED1(${1:pred},${1:val1})"
		],
		"description":"Predicate AssertionsThe following assertions enable more \ncomplex predicates to be verified while printing a more clear \nfailure message than if EXPECT_TRUE were used alone.\n\n++++++++++++++++++++++++++++++++++++++++\nEXPECT_PRED*\nEXPECT_PRED1(pred,val1)\nEXPECT_PRED2(pred,val1,val2)\nEXPECT_PRED3(pred,val1,val2,val3)\nEXPECT_PRED4(pred,val1,val2,val3,val4)\nEXPECT_PRED5(pred,val1,val2,val3,val4,val5)\n\nASSERT_PRED1(pred,val1)\nASSERT_PRED2(pred,val1,val2)\nASSERT_PRED3(pred,val1,val2,val3)\nASSERT_PRED4(pred,val1,val2,val3,val4)\nASSERT_PRED5(pred,val1,val2,val3,val4,val5)\n----------------------------------------\n\nVerifies that the predicate pred returns true when \npassed the given values as arguments.\n\nThe parameter pred is a function or functor that \naccepts as many arguments as the corresponding macro accepts \nvalues. If pred returns true for the given arguments, the assertion \nsucceeds, otherwise the assertion fails.\n\nWhen the assertion fails, it prints the value of each \nargument. Arguments are always evaluated exactly once.\n\nAs an example, see the following code:\n\n++++++++++++++++++++++++++++++++++++++++\n// Returns true if m and n have no common divisors except 1.\nbool MutuallyPrime(int m, int n) { ... }\n...\nconst int a = 3;\nconst int b = 4;\nconst int c = 10;\n...\nEXPECT_PRED2(MutuallyPrime, a, b);  // Succeeds\nEXPECT_PRED2(MutuallyPrime, b, c);  // Fails\n----------------------------------------\n\nIn the above example, the first assertion succeeds, \nand the second fails with the following message:\n\n++++++++++++++++++++++++++++++++++++++++\nMutuallyPrime(b, c) is false, where\nb is 4\nc is 10\n----------------------------------------\n\nNote that if the given predicate is an overloaded \nfunction or a function template, the assertion macro might not \nbe able to determine which version to use, and it might be necessary \nto explicitly specify the type of the function. For example, \nfor a Boolean function IsPositive() overloaded to take either \na single int or double argument, it would be necessary to write \none of the following:\n\n++++++++++++++++++++++++++++++++++++++++\nEXPECT_PRED1(static_cast<bool (*)(int)>(IsPositive), 5);\nEXPECT_PRED1(static_cast<bool (*)(double)>(IsPositive), 3.14);\n----------------------------------------\n\nWriting simply EXPECT_PRED1(IsPositive, 5); \nwould result in a compiler error. Similarly, to use a template \nfunction, specify the template arguments:\n\n++++++++++++++++++++++++++++++++++++++++\ntemplate <typename T>\nbool IsNegative(T x) {\n  return x < 0;\n}\n...\nEXPECT_PRED1(IsNegative<int>, -5);  // Must specify type for IsNegative\n----------------------------------------\n\nIf a template has multiple parameters, wrap the \npredicate in parentheses so the macro arguments are parsed correctly:\n\nASSERT_PRED2((MyPredicate<int, int>), 5, 0); \n"
	},
	//TODO EXPECT_PRED_FORMAT1 2 3
	"EXPECT_PRED_FORMAT1": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_PRED_FORMAT1",
		"body":[
			"EXPECT_PRED_FORMAT1(${1:pred_formatter},${1:val1})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nEXPECT_PRED_FORMAT1(pred_formatter,val1)\nEXPECT_PRED_FORMAT2(pred_formatter,val1,val2)\nEXPECT_PRED_FORMAT3(pred_formatter,val1,val2,val3)\nEXPECT_PRED_FORMAT4(pred_formatter,val1,val2,val3,val4)\nEXPECT_PRED_FORMAT5(pred_formatter,val1,val2,val3,val4,val5)\n\nASSERT_PRED_FORMAT1(pred_formatter,val1)\nASSERT_PRED_FORMAT2(pred_formatter,val1,val2)\nASSERT_PRED_FORMAT3(pred_formatter,val1,val2,val3)\nASSERT_PRED_FORMAT4(pred_formatter,val1,val2,val3,val4)\nASSERT_PRED_FORMAT5(pred_formatter,val1,val2,val3,val4,val5)\n----------------------------------------\n\nVerifies that the predicate pred_formatter succeeds when \npassed the given values as arguments.\n\nThe parameter pred_formatter is a predicate-formatter, \nwhich is a function or functor with the signature:\n\n++++++++++++++++++++++++++++++++++++++++\ntesting::AssertionResult PredicateFormatter(const char* expr1,\n                                            const char* expr2,\n                                            ...\n                                            const char* exprn,\n                                            T1 val1,\n                                            T2 val2,\n                                            ...\n                                            Tn valn);\n----------------------------------------\n\nwhere val1, val2, ..., valn are the values of the \npredicate arguments, and expr1, expr2, ..., exprn are the corresponding \nexpressions as they appear in the source code. The types T1, T2, \n..., Tn can be either value types or reference types; if an argument \nhas type T, it can be declared as either T or const T&, whichever \nis appropriate. For more about the return type testing::AssertionResult, \nsee Using a Function That Returns an AssertionResult.\n\nAs an example, see the following code:\n\n++++++++++++++++++++++++++++++++++++++++\n// Returns the smallest prime common divisor of m and n,\n// or 1 when m and n are mutually prime.\nint SmallestPrimeCommonDivisor(int m, int n) { ... }\n\n// Returns true if m and n have no common divisors except 1.\nbool MutuallyPrime(int m, int n) { ... }\n\n// A predicate-formatter for asserting that two integers are mutually prime.\ntesting::AssertionResult AssertMutuallyPrime(const char* m_expr,\n                                             const char* n_expr,\n                                             int m,\n                                             int n) {\n  if (MutuallyPrime(m, n)) return testing::AssertionSuccess();\n\n  return testing::AssertionFailure() << m_expr << \" and \" << n_expr\n      << \" (\" << m << \" and \" << n << \") are not mutually prime, \"\n      << \"as they have a common divisor \" << SmallestPrimeCommonDivisor(m, n);\n}\n\n...\nconst int a = 3;\nconst int b = 4;\nconst int c = 10;\n...\nEXPECT_PRED_FORMAT2(AssertMutuallyPrime, a, b);  // Succeeds\nEXPECT_PRED_FORMAT2(AssertMutuallyPrime, b, c);  // Fails\n----------------------------------------\n\nIn the above example, the final assertion fails and \nthe predicate-formatter produces the following failure message:\n\n++++++++++++++++++++++++++++++++++++++++\nb and c (4 and 10) are not mutually prime, as they have a common divisor 2\n----------------------------------------\n\n "
	},
	"EXPECT_HRESULT_SUCCEEDED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_HRESULT_SUCCEEDED",
		"body":[
			"EXPECT_HRESULT_SUCCEEDED(${1:expression})"
		],
		"description":"Verifies that expression is a success HRESULT."
	},
	"ASSERT_HRESULT_SUCCEEDED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_HRESULT_SUCCEEDED",
		"body":[
			"ASSERT_HRESULT_SUCCEEDED(${1:expression})"
		],
		"description":"Verifies that expression is a success HRESULT."
	},
	"EXPECT_HRESULT_FAILED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_HRESULT_FAILED",
		"body":[
			"EXPECT_HRESULT_FAILED(${1:expression})"
		],
		"description":"Verifies that expression is a success HRESULT."
	},
	"ASSERT_HRESULT_FAILED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_HRESULT_FAILED",
		"body":[
			"ASSERT_HRESULT_FAILED(${1:expression})"
		],
		"description":"Verifies that expression is a success HRESULT."
	},
	"EXPECT_DEATH": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_DEATH",
		"body":[
			"EXPECT_DEATH(${1:statement},${1:matcher})"
		],
		"description":"Death AssertionsThe following assertions verify that a piece \nof code causes the process to terminate. For context, see Death \nTests.\n\nThese assertions spawn a new process and execute the \ncode under test in that process. How that happens depends on the \nplatform and the variable ::testing::GTEST_FLAG(death_test_style), \nwhich is initialized from the command-line flag --gtest_death_test_style.\n\nOn POSIX systems, fork() (or \nclone() on Linux) is used to spawn the child, after which:If the \nvariable’s value is \"fast\", the death test statement is \nimmediately executed.If the variable’s value is \"threadsafe\", \nthe child process re-executes the unit test binary just as it \nwas originally invoked, but with some extra flags to cause just \nthe single death test under consideration to be run.On Windows, \nthe child is spawned using the CreateProcess() API, and re-executes \nthe binary to cause just the single death test under consideration \nto be run - much like the \"threadsafe\" mode on POSIX.Other values \nfor the variable are illegal and will cause the death test to fail. \nCurrently, the flag’s default value is \"fast\".\n\nIf the death test statement runs to completion without \ndying, the child process will nonetheless terminate, and the \nassertion fails.\n\nNote that the piece of code under test can be a compound \nstatement, for example:\n\n++++++++++++++++++++++++++++++++++++++++\nEXPECT_DEATH({\n  int n = 5;\n  DoSomething(&n);\n}, \"Error on line .* of DoSomething()\");\n\nEXPECT_DEATH(statement,matcher)\nASSERT_DEATH(statement,matcher)\n----------------------------------------\n\nVerifies that statement causes the process to terminate \nwith a nonzero exit status and produces stderr output that matches \nmatcher.\n\nThe parameter matcher is either a matcher for a const \nstd::string&, or a regular expression (see Regular Expression \nSyntax)—a bare string s (with no matcher) is treated as ContainsRegex(s), \nnot Eq(s).\n\nFor example, the following code verifies that calling \nDoSomething(42) causes the process to die with an error message \nthat contains the text My error:\n\n++++++++++++++++++++++++++++++++++++++++\nEXPECT_DEATH(DoSomething(42), \"My error\");\n----------------------------------------\n\n "
	},
	"ASSERT_DEATH": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_DEATH",
		"body":[
			"ASSERT_DEATH(${1:statement},${1:matcher})"
		],
		"description":"Verifies that statement causes the process to terminate with a nonzero exit status and produces stderr output that matches matcher. "
	},
	"EXPECT_DEATH_IF_SUPPORTED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_DEATH_IF_SUPPORTED",
		"body":[
			"EXPECT_DEATH_IF_SUPPORTED(${1:statement},${1:matcher})"
		],
		"description":"If death tests are supported, behaves the same as EXPECT_DEATH. Otherwise, verifies nothing. "
	},
	"ASSERT_DEATH_IF_SUPPORTED": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_DEATH_IF_SUPPORTED",
		"body":[
			"ASSERT_DEATH_IF_SUPPORTED(${1:statement},${1:matcher})"
		],
		"description":"If death tests are supported, behaves the same as EXPECT_DEATH. Otherwise, verifies nothing. "
	},
	"EXPECT_DEBUG_DEATH": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_DEBUG_DEATH",
		"body":[
			"EXPECT_DEBUG_DEATH(${1:statement},${2:matcher})"
		],
		"description":"In debug mode, behaves the same as EXPECT_DEATH. When not in debug mode (i.e. NDEBUG is defined), just executes statement."
	},
	"EXPECT_EXIT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:EXPECT_EXIT",
		"body":[
			"EXPECT_EXIT(${1:statement},${2:predicate},${3:matcher})"
		],
		"description":"++++++++++++++++++++++++++++++++++++++++\nEXPECT_EXIT(statement,predicate,matcher)\nASSERT_EXIT(statement,predicate,matcher)\n----------------------------------------\n\nVerifies that statement causes the process to terminate \nwith an exit status that satisfies predicate, and produces stderr \noutput that matches matcher.\n\nThe parameter predicate is a function or functor \nthat accepts an int exit status and returns a bool. GoogleTest \nprovides two predicates to handle common cases:\n\n++++++++++++++++++++++++++++++++++++++++\n// Returns true if the program exited normally with the given exit status code.\n::testing::ExitedWithCode(exit_code);\n\n// Returns true if the program was killed by the given signal.\n// Not available on Windows.\n::testing::KilledBySignal(signal_number);\n----------------------------------------\n\nThe parameter matcher is either a matcher for a const \nstd::string&, or a regular expression (see Regular Expression \nSyntax)—a bare string s (with no matcher) is treated as ContainsRegex(s), \nnot Eq(s).\n\nFor example, the following code verifies that calling \nNormalExit() causes the process to print a message containing \nthe text Success to stderr and exit with exit status code 0:\n\n++++++++++++++++++++++++++++++++++++++++\nEXPECT_EXIT(NormalExit(), testing::ExitedWithCode(0), \"Success\");\n----------------------------------------\n\n "
	},
	"ASSERT_EXIT": {
		"scope": "c,cpp",
		"prefix": "g:Assertions:ASSERT_EXIT",
		"body":[
			"ASSERT_EXIT(${1:statement},${2:predicate},${3:matcher})"
		],
		"description":"See Also EXPECT_EXIT"
	},
	//https://google.github.io/googletest/reference/matchers.html
	"Eq": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Eq",
		"body":[
			"Eq(${1:value})"
		],
		"description":"argument == value Generic ComparisonMatcherDescription\n\n++++++++++++++++++++++++++++++++++++++++\nEq(value) or valueargument == value\nGe(value)argument >= value\nGt(value)argument > value\nLe(value)argument <= value\nLt(value)argument < value\nNe(value)argument != value\nIsFalse()argument evaluates to false in a Boolean context.\nIsTrue()argument evaluates to true in a Boolean context.\nIsNull()argument is a NULL pointer (raw or smart).\nNotNull()argument is a non-null pointer (raw or smart).\nOptional(m)argument is optional<> that contains a value matching m. (For testing whether an optional<> is set, check for equality with nullopt. You may need to use Eq(nullopt) if the inner type doesn't have ==.)\nVariantWith<T>(m)argument is variant<> that holds the alternative of type T with a value matching m.\nRef(variable)argument is a reference to variable.\nTypedEq<type>(value)argument has type type and is equal to value. You may need to use this instead of Eq(value) when the mock function is overloaded.\n----------------------------------------\n\nExcept Ref(), these matchers \nmake a copy of value in case it's modified or destructed later. \nIf the compiler complains that value doesn't have a public copy \nconstructor, try wrap it in std::ref(), e.g. Eq(std::ref(non_copyable_value)). \nIf you do that, make sure non_copyable_value is not changed afterwards, \nor the meaning of your matcher will be changed.\n\nIsTrue and IsFalse are useful when you need to use \na matcher, or for types that can be explicitly converted to Boolean, \nbut are not implicitly converted to Boolean. In other cases, \nyou can use the basic EXPECT_TRUE and EXPECT_FALSE assertions. \n"
	},
	"Ge": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Ge",
		"body":[
			"Ge(${1:value})"
		],
		"description":"argument >= value"
	},
	"Gt": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Gt",
		"body":[
			"Gt(${1:value})"
		],
		"description":"argument > value"
	},
	"Le": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Le",
		"body":[
			"Le(${1:value})"
		],
		"description":"argument <= value"
	},
	"Lt": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Lt",
		"body":[
			"Lt(${1:value})"
		],
		"description":"argument < value"
	},
	"Ne": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Ne",
		"body":[
			"Ne(${1:value})"
		],
		"description":"argument != value"
	},
	"IsFalse": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:IsFalse",
		"body":[
			"IsFalse()"
		],
		"description":"argument evaluates to false in a Boolean context."
	},
	"IsTrue": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:IsTrue",
		"body":[
			"IsTrue()"
		],
		"description":"argument evaluates to true in a Boolean context."
	},
	"IsNull": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:IsNull",
		"body":[
			"IsNull()"
		],
		"description":"argument is a NULL pointer (raw or smart)."
	},
	"NotNull": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:NotNull",
		"body":[
			"NotNull()"
		],
		"description":"argument is a non-null pointer (raw or smart)."
	},
	"Optional": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Optional",
		"body":[
			"Optional(${1:m})"
		],
		"description":"argument is optional<> that contains a value matching m. (For testing whether an optional<> is set, check for equality with nullopt. You may need to use Eq(nullopt) if the inner type doesn’t have ==.)"
	},
	"VariantWith": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:VariantWith",
		"body":[
			"VariantWith<${1:T}>(${1:m})"
		],
		"description":"argument is variant<> that holds the alternative of type T with a value matching m."
	},
	"Ref": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:Ref",
		"body":[
			"Ref(${1:variable})"
		],
		"description":"argument is a reference to variable."
	},
	"TypedEq": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:TypedEq",
		"body":[
			"TypedEq<${1:type}>(${1:value})"
		],
		"description":"argument has type type and is equal to value. You may need to use this instead of Eq(value) when the mock function is overloaded."
	},

	"Matchers Reference": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:#Matchers Reference",
		"body":[
			"#Matchers Reference"
		],
		"description":"Generic ComparisonMatcherDescription\n\n++++++++++++++++++++++++++++++++++++++++\nEq(value) or valueargument == value\nGe(value)argument >= value\nGt(value)argument > value\nLe(value)argument <= value\nLt(value)argument < value\nNe(value)argument != value\nIsFalse()argument evaluates to false in a Boolean context.\nIsTrue()argument evaluates to true in a Boolean context.\nIsNull()argument is a NULL pointer (raw or smart).\nNotNull()argument is a non-null pointer (raw or smart).\nOptional(m)argument is optional<> that contains a value matching m. (For testing whether an optional<> is set, check for equality with nullopt. You may need to use Eq(nullopt) if the inner type doesn't have ==.)\nVariantWith<T>(m)argument is variant<> that holds the alternative of type T with a value matching m.\nRef(variable)argument is a reference to variable.\nTypedEq<type>(value)argument has type type and is equal to value. You may need to use this instead of Eq(value) when the mock function is overloaded.\n----------------------------------------\n\nExcept Ref(), these matchers \nmake a copy of value in case it's modified or destructed later. \nIf the compiler complains that value doesn't have a public copy \nconstructor, try wrap it in std::ref(), e.g. Eq(std::ref(non_copyable_value)). \nIf you do that, make sure non_copyable_value is not changed afterwards, \nor the meaning of your matcher will be changed.\n\nIsTrue and IsFalse are useful when you need to use \na matcher, or for types that can be explicitly converted to Boolean, \nbut are not implicitly converted to Boolean. In other cases, \nyou can use the basic EXPECT_TRUE and EXPECT_FALSE assertions. \n"
	},
	"Generic Comparison": {
		"scope": "c,cpp",
		"prefix": "g:Matchers:#Generic Comparison",
		"body":[
			"#Generic Comparison"
		],
		"description":"Generic Comparison\n\n++++++++++++++++++++++++++++++++++++++++\nMatcherDescription\nEq(value) or valueargument == value\nGe(value)argument >= value\nGt(value)argument > value\nLe(value)argument <= value\nLt(value)argument < value\nNe(value)argument != value\nIsFalse()argument evaluates to false in a Boolean context.\nIsTrue()argument evaluates to true in a Boolean context.\nIsNull()argument is a NULL pointer (raw or smart).\nNotNull()argument is a non-null pointer (raw or smart).\nOptional(m)argument is optional<> that contains a value matching m. (For testing whether an optional<> is set, check for equality with nullopt. You may need to use Eq(nullopt) if the inner type doesn't have ==.)\nVariantWith<T>(m)argument is variant<> that holds the alternative of type T with a value matching m.\nRef(variable)argument is a reference to variable.\nTypedEq<type>(value)argument has type type and is equal to value. You may need to use this instead of Eq(value) when the mock function is overloaded.\nExcept Ref(), these matchers make a copy of value in case it's modified or destructed later. If the compiler complains that value doesn't have a public copy constructor, try wrap it in std::ref(), e.g. Eq(std::ref(non_copyable_value)). If you do that, make sure non_copyable_value is not changed afterwards, or the meaning of your matcher will be changed.\n----------------------------------------\n\nIsTrue and IsFalse are useful when you need to \nuse a matcher, or for types that can be explicitly converted to \nBoolean, but are not implicitly converted to Boolean. In other \ncases, you can use the basic EXPECT_TRUE and EXPECT_FALSE assertions. \n"
	},
}
